\documentclass{automatextcc}

% Caminho da Pasta das Figuras
\graphicspath{{figuras/}}

%\makeindex  Opcional (Índice Remissivo)


\begin{document}


\title{Composição Automática de Músicas utilizando Redes Neurais Recorrentes}
\author{Nicolas Mathias Hahn}

% orientador(a) do trabalho {nome}{Orientador(a)}
\advisor{Prof. Dr. Guilherme Pumi}{Orientador}
% universidade onde obteve o título e atual
\advisorinfo{Doutor pela Universidade Federal do Rio Grande do Sul, Porto Alegre, RS}{UFRGS}

% banca examinadora:
\examinera{Prof. Dr. xxx}
\examinerainfo{Doutor pela XX -- Cidade, Estado}{Universidade}

% departamento:
\dept{\DEST}

% data de entrega
\date{Outubro de 2022}


% Capa
\maketitulo

% Folha de rosto
\makefolhaderosto

% Folha de aprovação
\makefolhadeaprovacaoA % Um membro na banca
%\makefolhadeaprovacaoB % Dois membros na banca


% Epígrafe (OPCIONAL)
\newpage
\vspace*{\fill}
\begin{flushright} % mexer aqui
	\textit{``Since I have always preferred making plans to executing them, I have gravitated towards situations and systems that, once set into operation, could create music with little or no intervention on my part. That is to say, I tend towards the roles of planner and programmer, and then become an audience to the results.''} \newline
	\textit{Brian Eno (Alpern, 1995)}.
\end{flushright}

% Agradecimentos
\newpage
\chapter*{Agradecimentos}
Agradeço a xxx. Opcional % mexer aqui

% palavras chave
    % português
\keyword{Redes Neurais}
\keyword{Música}
    % inglês
\keyworde{Neural Networks}
\keyworde{Music}

% resumo 
    % português
\begin{abstract}
Este trabalho ....
\end{abstract}
    % inglês
\begin{englishabstract}
In this work ....
\end{englishabstract}

% sumário (Obrigatório)
\tableofcontents

% lista de ilustrações (Obrigatório)
\listoffigures

% lista de tabelas (Obrigatório)
\listoftables


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Introdução
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introdução}

% processo de composição algoritmica antes da utilização dos computadores
A ideia de utilizar instruções formais e processos para criar músicas data tão antigamente quanto os gregos antigos. Portanto, aplicações teóricas de números (i.e. ``dados'', num sentido), e várias propriedades matemáticas derivadas da natureza foram os formalismos, ou ``algoritmos'', em que os gregos construíram seus sistemas musicais. Esses formalismos dos gregos antigos, no entanto, estão enraizados majoritariamente em teoria, e suas aplicações em performance musical são provavelmente questionáveis, considerando que músicas gregas são quase inteiramente improvisadas \citep{grout1996}. Portanto, enquanto as conjecturas matemáticas gregas certamente criaram um sistema musical de intervalos e modas em que o músico operava e provavelmete também se guiava e influenciava sua performance de alguma forma, o músico não era de forma alguma inteiramente removido do processo de tomada de decisão. Portanto, músicas da antiga Grécia não eram ``composição algoritmicas'' em sua forma pura, mas é sem dúvidas importante historicamente na música pela sua tendência em direção aos processos extra-humanos.


Uma camada extra de abstração foi obtida no fim do século XV com o nascimento da composição ``canônica''. O método predominante era escrever uma única voz e fornecer instruções aos músicos para derivarem vozes adicionais com base na voz base. A instrução ou regra pela qual essas outras vozes foram derivadas é denominada \texit{canon}, que significa ``regra'' ou ``lei''. Essas ``regras'' são de fato ``algoritmos'' pelos quais os intérpretes desdobravam a música. Nesse caso, oposto ao dos antigos Gregos, podemos observar uma clara remoção do compositor por uma grande parte do processo composicional: o compositor invernta um \textit{kernel} da música - uma única melodia ou seção - em que uma composição inteira é construída \citep{grout1996}. % verificar...


De acordo com \cite{alpern1995}, Mozart também utilizou técnicas de composição automática em sua \textit{Musikalisches Wurfelspiel} (``Dice Music''), um jogo musical em que envolvia uma montagem de fragmentos de músicas combinados pelo acaso gerando uma nova peça musical. Esta forma simples de composição ``algoritmica'' deixa o processo criativo nas mãos do acaso, em que o rolar de um dado decide quais notas serão utilizadas.


Existem exemplo mais modernos de composição algoritmica sem o uso de computadores. John Cage, assim como Mozart, utilizou aleatorização in várias de suas composições, como as realizadas em \textit{Reunion}, criada ao jogar xadrez em um tabuleiro equipado com um fotorreceptor: as jogadas dos enxadristas acionavam sons, e, consequentemente, a peça musical era diferente a cada vez que era performada \citep{alpern1995}.


% composição algoritmica
A área de composição automática refere-se ao processo de utilizar um processo formal para a composição musical com o mínimo de intervenção humana. Esse processo é usualmente realizado com em um computador, com o auxílio de vários formalismos: geração de números aleatórios, sistemas \textit{rule-based} e diversos outros algoritmos.


Composição algoritmica, também chamada de ``composição automática'', basicamente refere-se ao ``processo de utilização de algum processo formal para composição musical com o mínimo de intervenção humana'' \citep{alpern1995}. Tais ``processos formais''

% TEXTOS JOGADOS ABAIXO
Algorithmic composition, sometimes also referred to as "automated composition," basically refers to "the process of using some formal process to make music with minimal human intervention" (Alpern, 1995). Such "formal processes," as we will see, have been familiar to music since ancient times. The title itself, however, is relatively new—the term "algorithm" having been adopted from the fields of computer science and information science around the halfway mark of the 20th century (Burns, 1997). Computers have given composers new opportunities to automate the compositional process. Furthermore, as we will explore, several different methods of doing so have developed in the last forty years or so.

To begin with the title itself, Webster's dictionary defines an "algorithm" simply as "a predetermined set of instructions for solving a specific problem in a limited number of steps." The "problem" composers are faced with, of course, is creating music; the "instructions" for creating this music according to the definition are "predetermined," suggesting that intervention on the part of the human composer is superceded once the compositional process itself is set into motion, as hinted at as well in the above Brian Eno quote. Thus, "automated composition" also suitably describes this kind of music, since "automation" refers to "anything that can move or act of itself."

The earliest instance of computer generated composition is that of Lejaren Hiller and Leonard Isaacson at the University of Illinois in 1955-56. Using the Illiac high-speed digital computer, they succeeded in programming basic material and stylistic parameters which resulted in the Illiac Suite (1957). The score of the piece was composed by the computer and then transposed into traditional musical notation for performance by a string quartet. What Hiller and Isaacson had done in the Illiac Suite was to (a.) generate certain "raw materials" with the computer, (b.) modify these musical materials according to various functions, and then (c.) select the best results from these modifcations according to various rules (Alpern, 1995). This "generator/modifier/selector" paradigm was also later applied to MUSICOMP, one of the first computer systems for automated composition, written in the late 1950s and early 1960s by Hiller and Robert Baker, which realized Computer Cantata: "Since [MUSICOMP] was written as a library of subroutines, it made the process of writing composition programs much easier, as the programmer/composer could use the routines within a larger program that suited his or her own style" (Alpern, 1995; italics added). This idea of building small, well-defined compositional functions—i.e. "subroutines"—and assembling them together would prove efficient and allow the system a degree of flexibility and generality (Alpern, 1995), which has made this approach a popular one, as we will see, in many algorithmic composition systems even into the present day.

Another pioneering use of the computer in algorithmic compostion is that of Iannis Xenakis, who created a program that would produce data for his "stochastic" compositions, which he had written about in great detail in his book Formalized Music (1963). Xenakis used the computer's high-speed computations to calculate various probability theories to aid in compositions like Atrées (1962) and Morsima-Amorsima (1962). The program would "deduce" a score from a "list of note densities and probabilistic weights supplied by the programmer, leaving specific decisions to a random number generator" (Alpern, 1995). "Stochastic" is a term from mathematics which designates such a process, "in which a sequence of values is drawn from a corresponding sequence of jointly distributed random variables" (Webster's dictionary). As in the previous example of the Illiac Suite, these scores were performed by live performers on traditional instruments.

With Xenakis, it should be noted, however, "the computer has not actually produced the resultant sound; it has only aided the composer by virtue of its high-speed computations" (Cope, 1984): in essence, what the computer was outputing was not the composition itself but material with which Xenakis could compose. In contrast, the work of Hiller and Isaacson attempted to simulate the compositional process itself entirely, completely delegating creative decisions to the computer.

Already in these first two examples—Xenakis and Hiller—we find two different methodologies that exist in computer-generated algorithmic composition: (1.) "stochastic" vs. (2.) "rule-based" systems. As we will see, there is also a third category, (3.) which we can label AI, or artificial intelligence systems.

Stochastic approaches, already somewhat touched upon, are the simplest. These involve randomness and can be as simple as generating a random series of notes, as seen already in the case of Mozart's Dice Music and in the works of John Cage, though a great amount of conceptual complexity can also be introduced to the computations through the computer with statistical theory and Markov chains. Basically, many of the creative decisions in the stochastic method are merely left to chance, essentially the same as drawing notes out of a hat. Another example of non-computer-oriented "stochastic" composition can be found in Karlheinz Stockhausen's Klaveirstucke XI in that the sequence of various fragments of music are to be performed by a pianist in random sequence. A different slant to usages of unexpectedness is that of applying chaos theory to algorithmic composition (Burns, 1997). These applications employ various nonlinear dynamics equations that have been deduced from nature and other chaotic structures such as fractals to relay different musical information:

"In recent years [the '70s and '80s], the behaviour of systems of nonlinear dynamical equations when iterated has generated interest into their uses as note generation algorithms. The systems are described as systems of mathematical equations, and, as noted by Bidlack and Leach, display behaviours found in a large number of systems in nature, such as the weather, the mixing of fluids, the phenomenon of turbulence, population cycles, the beating of the human heart, and the lengths of time between water droplets dripping from a leaky faucet" (Alpern, 1995).
This is a large and mathematically complex field of algorithmic composition, and the author refers the interested reader to my website on the topic as well as to the article by Jeremy Leach ("Nature, Music, and Algorithmic Composition." Computer Music Journal, 1995) as good starting points for more in-depth investigation.

A second approach to algorithmic composition using the computer is that of "rule-based" systems and formal grammars: "An elementary example of a rule-based process would center around a series of tests, or rules, through which the program progresses. These steps are usually constructed in such a way that the product of the steps leads to the next new step" (Burns, 1997). Non-computer parallels to rule-based algorithmic composition that have been previously mentioned include the 15th-century canon of the Renaissance period as well as the post-WWII twelve-tone method and integral serialism. Rather than delegating decisions to chance as in the stochastic methods just described, rule-based systems pre-compose a "constitution," so to say, or a "grammer," by which the compositional process must behave once set into motion—"grammar" being a term borrowed from linguistic theory which designates the formal system of principles or rules by which the possible sentences of a language are generated (Burns, 1997). Like Hiller's MUSICOMP, these efforts usually take the form of a computer program or a unified system of subroutines, and often also involve databases of various rules either collected from compositional techniques of the past or newly invented. One example of using a "rule-based" method of algorithmic composition is that of William Shottstaedt's automatic species counterpoint program that writes music based on rules from Johann Joseph Fux' Gradus ad Parnassum, a counterpoint instruction book from the early 18th-century aimed at guiding young composers to recreate the strictly controlled polyphonic style of Palestrina (1525-1594) (Grout, 1996):

"The program is built around almost 75 rules, such as 'Parallel fifths are not allowed' and 'Avoid tritones near the cadence in lydian mode.' Schottstaedt assigned a series of 'penalties' for breaking the rules. These penalties are weighted based on the fact that Fux indicated that there were some rules that could never be broken, but others did not have to be adhered to as vehemently. As penalties accumulate, the program abandons its current branch of rules and backtracks to find a new solution" (Burns, 1997).
Another example is that of Kemal Ebcioglu's automated system called CHORAL which generates four-part chorales in the style of J. S. Bach according to over 350 rules (Burns, 1997).

One last unique approach that I found to algorithmic composition using the computer is that of aritifical intelligence (AI) systems. These systems are like rule-based systems in that they are programs, or systems of programs, based on some pre-defined grammar; however, AI systems have the further capacity of defining their own grammar—or, in essence, a capacity to "learn." An example of this is David Cope's system called Experiments in Musical Intelligence (EMI). Like the previous example of Shottstaedt and of Ebcioglu's CHORAL, EMI is based on a large database of style descriptions, or rules, of different compositional strategies. However, EMI also has the capactiy to create its own grammar and database of rules, which the computer itself deduces based on several scores from a specific composer's work that are input to it. EMI has been used to automatically compose music that evokes already somewhat successfully the styles of Bach, Mozart, Bartók, Brahms, Joplin, and many others.

Another interesting branch of AI techniques is that of "genetic programming," a very recent technique in the field of computer science for "automatic programming" of computers (Alpern, 1995). Rather than basing its grammar on scores input to the computer as in EMI, genetic programming generates its own musical materials as well as form its own grammar. The composer must also program a "critic" function, therefore, which then listens to the numerous automatically produced outputs at various stages of the processing to decide which are "fit" or suitable for final output (the composer having final say, then, as to which of these to discard and which to save). Below is a more in-depth description of the different processes involved in genetic programming methods:

"[Genetic programming] is a method which actually uses a process of artificially-created natural selection to evolve simple computer programs. In order to perfrom this process, one uses a small set of functions and terminals, or constants, to describe the domain one wishes an evolved program to operate in. For example, if the human programmer wishes to evolve a program which can generate or modify music, one would give it functions which manipulate music, doing things such as transposition, note generations, stretching or shrinking of time values, etc. Once the functions have been decided on, the genetic programming system will create a population of programs which have been randomly generated from the provided function set. Then, a fitness measure is determined for each program. This is a number describing how well the program performs in the given problem domain. Since the initial programs are randomly generated, their performance will be very poor—however, a few programs are likely to do slightly better than the rest. These will be selected in pairs, proportionate to their fitness measure, and then a new population of programs will be created from these individuals, and the whole process will be repeated, until a solution is reached (in the form of a program which satisfies the critic), or a set of number of iterations has passed. Operations which may be performed in generating this new population include reproduction (passing an individual program on into the next generation unchanged), crossover (swapping pieces of code between two 'parent' programs in order to create two unique 'children'), mutation, permutation, and others" (Alpern, 1995).
The composer, thus, provides the system with a library of functions, or subroutines, as we have already seen in the case of Hiller's MUSICOMP and other systems, which can do various things to the generated musical materials: however, in this case, the composer does not define the way in which these functions will be used—the composer merely defines for the computer what is desirable in an output (i.e. designs a "critic") and the computer in turn tries to automatically achieve these results using the provided subroutines. This form of "algorithmic composition," thus, (using AI or genetic programming) can be seen as an extreme case, abstracting itself even from its own "algorithm" since the output it produces as well as the formal process by which it performs is automatically constructed.

Besides the three various methods of algorithmic composition using the computer that I have described—stochastic, rule-based, and AI—further distinction also occurs in the type of musical output different algorithmic composition systems produce. Some systems specify score information only (i.e. pitch, duration, and dynamic material) to be realized by whatever acoustic or electronic instruments, as seen already in the early cases of Hiller and Xenakis and which is also true in the case of Cope's EMI compositions (the MIDI scores of which are fed into a Disclavier or other MIDI sound device for output) and most others mentioned in this paper. Other systems, however, do not create scores and focus instead on electronic sound synthesis or manipulation of recorded sounds (i.e. musique concréte), or on a combination of these activities. Sound synthesis algorithms, furthermore, "have been used in a variety of ways, from the calculation of complex waveforms (building sounds), to the evolution of timbre development over time" (Burns, 1997). A last approach is to combine both score and electronic sound synthesis in the system's output, controlling both structural content and its own timbral realization.

% certamente olhar este artigo e suas bibliografias:
% https://ccrma.stanford.edu/~blackrse/algorithm.html

% talvez olhar este artigo:
% https://musica.ufmg.br/nasnuvens/wp-content/uploads/2020/11/2016-38-A-interatividade-nas-trilhas-sonoras-de-jogos-digitais-e-um-comparativo-com-a-música-de-cinema.pdf



% referencial teórico
\section{Referencial Teórico}

    % RNN 
\subsection{Redes Neurais Recorrentes - RNN}

% https://en.wikipedia.org/wiki/Recurrent_neural_network
% https://www.ibm.com/cloud/learn/recurrent-neural-networks
% https://matheusfacure.github.io/2017/07/12/activ-func/
\subsubsection{CharRNN}
\subsubsection{Long Short-Term Memory - LSTM}
\subsection{Função de Ativação}
O objetivo da função de ativação é determinar se o neurônio de uma rede neural será ativado ou não. É uma função não linear que tipicamente converte o resultado de um neurônio para um valor dentro do intervalo $[0,1]$ ou $[-1,1]$. Dentre as funções mais comuns, podemos citar três:

\begin{itemize}
    \item sigmóide: $g(x) = \frac{1}{1+e^{-x}}$ 
    % grafico da sigmóide
    \item tangente hiperbólica (tanh): $g(x) = \frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}$
    % grafico da tanh
    \item ReLU: $g(x) = max(0,x)$
    % grafico da ReLU
\end{itemize}

% coletei do site da ibm, mas falta tratar texto e coletar fonte formal

    % notação ABC
\subsection{Notação ABC}

ABC é uma linguagem para notação de música - melodia, letra e cifra - usando caracteres em formato ASCII - \textit{American Standard Code for Information Interchange} (sistema de representação de letras, algarismos e sinais de pontuação e de controle, através de um sinal codificado em forma de código binário - cadeias de bits formada por vários 0 e 1 - desenvolvido a partir de 1960, que representa um conjunto de 128 sinais: 95 sinais gráficos - letras do alfabeto latino, algarismos arábicos, sinais de pontuação e sinais matemáticos - e 33 sinais de controle, utilizando 7 bits para representar todos os seus símbolos.). Desde a introdução ao final de 1991 por Chris Walshaw, se tornou muito popular e existem agora vários programas (para sistemas operacionais diversos, como Windows, MacOS, Unix e mesmo para PDAs) que podem ler notação ABC, convertendo-a em partitura ou tocando-a através de alto-falantes de um computador. Uma característica única de programas ABC é a possibilidade de manipular tanto coletâneas de músicas quanto peças musicais individuais.

\newpage
Exemplo: \newline
X: 308                  \% número da peça (index) \newline
T: Quem não sabe lê     \% título \newline
O: Bahia, capital       \% origem \newline
M: 2/4                  \% metro (compasso) \newline
L: 1/16                 \% unidade de duração \newline
Q: 1/4=84               \% andamento (tempo) \newline
K: A                    \% tom \newline
\% \newline
"A"A2 A2 c3 A | "Bm"B8 | "D"A2 A2 d3 c | "A"B A A A - A A3 | \newline 
w: Quem não sa-be lê Quem não sa-be lê o A-be--cê \newline
\% \newline
"A"A2 A2 e3 c | "Bm"B8 | "D"A2 A2 d3 c | "A"B A A A - A A3 | \newline
w: Ve-nha is-tu-dar Ve-nha is-tu-dar o Be-a--bá


% falta:
% - tratar texto (basicamente ctrl+c e ctrl+v) 
% - inserir imagem/explicacoes do formato

% fonte: https://en.wikipedia.org/wiki/ABC_notation
% falta localizar bibliografia mais formal


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Metodologia
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Metodologia}

% coleta de dados
\section{Coleta de Dados}

A coleta de dados foi realizada por meio de um \textit{crawler/bot}, desenvolvido na linguagem \href{https://python.org/}{Python}, para extrair músicas em formato \textit{.abc} do site \href{https://abcnotation.com/}{``abcnotation.com''}. Após uma semana de execução, foram obtidos 184.900 arquivos contendo diversas informações sobre as peças musicais (como título, autor, tonalidade, entre outras).

% tratamento de dados
\section{Tratamento de Dados}

% rede neural
\section{Rede Neural}
    % arquitetura
\subsection{Arquitetura}
    % parâmetros de treinamento
\subsection{Parâmetros de Treinamento}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Resultados
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Resultados}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Conclusão
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusão}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Referências
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Referências}




%%% DAQUI PRA BAIXO É ESTRUTURA ANTIGA A SER DESCARTADA

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMEÇA O TEXTO DO TRABALHO DE CONCLUSÃO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introdução}

A utilização de músicas é muito presente em filmes, séries, jogos; essas obras, que usualmente fazem parte de uma trilha sonora, têm os mais diversos estilos e servem para inúmeras finalidades (animar o expectador, emocioná-lo ou criar tensão, para citar algumas). No entanto, compor músicas não é algo simples e, muitas vezes, requer um compositor ou grupo de compositores para que seja criada uma nova faixa musical. Apesar disso, técnicas como modelagem sistêmica \citep[veja][]{da2017modelagem} ou machine learning (mais especificamente as técnicas de redes neurais) são exploradas com o intuito de realizar uma composição \citep[ver em][]{agarwala2017music} seja como inspiração para o compositor, seja como uma automatização do processo.

Este trabalho tem o intuito de revisar e estudar alguns dos métodos mais utilizados na literatura para composição musical, principalmente aqueles que requerem apenas arquivos de áudio (músicas ou MIDI - \textit{Musical Instrument Digital Interface}), como machine learning. Por exemplo, é possível desenvolver um modelo estatístico (utilizando redes neurais e técnicas de deep learning) que será treinado com diferentes músicas dos mais diversos estilos e, após isso, predizer (compor) uma nova peça utilizando uma seleção de faixas como entrada (input). Além disso, um dos pontos de partida deste trabalho é o de replicar e de validar o que foi apresentado em \cite{agarwala2017music}, coletar os dados das mesmas fontes citadas, como o \href{https://abcnotation.com/}{``abcnotation.com''} e o \href{https://thesession.org/}{``thesession.org''}, e procurar compor músicas o mais ``naturais'' possíveis, considerando a audição humana. 

Quando escutamos a uma música, nem sempre gostamos do que ouvimos, seja por uma questão de estilo ou pelo nosso momento atual. Independente do motivo, podemos afirmar que o ato de apreciar é subjetivo e pode ser diferente para cada indivíduo. Devido a isso, cada um pode ter percepções diferentes do que imagina ser uma música composta por computador (talvez com um caráter mais ``artificial'') e uma música composta por um ser humano (caráter mais ``natural''). Devido a isso, outro objetivo deste trabalho é o de propor uma pesquisa on-line em que será solicitado aos respondentes se o áudio escutado foi composto por uma máquina ou não. Além disso, serão comparadas também músicas resultantes dos modelos originados pelos métodos estudados e pela nova proposta de método. Por conseguinte, a pesquisa irá responder, idealmente, qual dos modelos mais compôs músicas similares a uma composição humana.



\newpage
\section{Metodologia de Pesquisa}

A presente pesquisa contém um caráter mais teórico do que aplicado, considerando que seu intuito principal é o de reproduzir e verificar os resultados apresentado em \cite{agarwala2017music}, bem como explorar e apresentar uma discussão das ferramentas de deep learning utilizadas para composição musical. Além disso, serão feitas aplicações das técnicas e métodos estudados para a composição de músicas inéditas baseadas em um conjunto personalizado de faixas musicais.

O primeiro passo compreende a coleta das músicas que formarão a base de dados de treino dos modelos. Para tal, utilizaremos sites como o \href{https://abcnotation.com/}{``abcnotation.com''} e o  \href{https://thesession.org/}{``thesession.org''} para a pesquisa (os arquivos vêm codificados no formato ABC, mas serão convertidos para MIDI). Após esse passo, serão realizadas análises descritivas dos dados coletados para se ter uma noção de estilos ou autores das músicas. Por conseguinte, serão treinados modelos utilizando diferentes técnicas de deep learning (como RNN - \textit{Recurrent Neural Networks}, CharRNN e CNN - \textit{Convolutional Neural Networks}) com o objetivo de compor peças musicais com base em uma coleção de músicas pré-selecionadas. Assim sendo, disponibilizaremos as faixas compostas a usuários para avaliarem se, na opinião deles, as músicas foram feitas por máquinas ou por seres humanos.

O desenvolvimento do estudo se dará por meio do software \href{https://www.python.org}{Python}, visto que é bastante utilizado na área de deep learning, além de \cite{agarwala2017music} conter um repositório no \href{https://github.com/yinoue93/CS224N_proj}{GitHub}. Logo, podemos resumir o método de pesquisa em 7 (sete) etapas:

\begin{itemize}
    \item \textbf{Etapa 1 - Revisão Bibliográfica}: estudar artigo base e revisar a literatura dos métodos utilizados para composição musical por meio de modelos.
    \item \textbf{Etapa 2 - Programação dos Algoritmos}: pesquisar, programar e entender como aplicar os métodos pesquisados para atingir o objetivo de composição musical.
    \item \textbf{Etapa 3 - Coleta de Dados}: estudar o código no repositório do artigo base para realizar a coleta dos dados por meio de um robô.
    \item \textbf{Etapa 4 - Desenvolvimento da Pesquisa}: treinar modelos com os diferentes métodos e compor músicas com diferentes conjuntos musicais selecionados.
    \item \textbf{Etapa 5 - Análise dos Resultados}: avaliar se as músicas resultantes foram compostas por máquinas por meio de uma pesquisa de opinião.
    \item \textbf{Etapa 6 - Discussão e Conclusão}: comentários sobre o estado da arte, desempenho dos modelos, obstáculos encontrados e possibilidades de expansão da pesquisa.
    \item \textbf{Etapa 7 - Redação Final da Monografia/Artigo}: polimento final dos textos, bem como organização de um repositório dos códigos utilizados.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Referencial Teórico
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%https://pdf.zlibcdn.com/dtoken/9d711d2ead6feb1b55416a2482f22ed6/Neural_Networks_and_Deep_Learning._A_Textbook_by_C_3583051_(z-lib.org).pdfhttps://pdf.zlibcdn.com/dtoken/9d711d2ead6feb1b55416a2482f22ed6/Neural_Networks_and_Deep_Learning._A_Textbook_by_C_3583051_(z-lib.org).pdf

%https://arxiv.org/pdf/1506.02078)

\newpage
\section{Referencial Teórico}

%\pumi{aqui o ideal é deixar implícito que um dos objetivos do trabalho é revisar o estado da arte no que tange composição artificial de músicas, citar quais são os artigos chave e dizer quais serão os artigos que focarás no trabalho. }

%\subsection{Referencial Teórico}
%\subsection{Estado da Arte}
%\subsection{Seu trabalho no contexto da literatura}

A principal referência utilizada neste trabalho foi o artigo \cite{agarwala2017music}. Demais fontes bibliográficas como \cite{da2017modelagem} e \cite{de2018deep} envolvem diferentes abordagens e técnicas para atingir um objetivo específico: compor músicas. Isso posto, compor músicas sem conhecer a linguagem musical é algo que tem sido cada vez mais explorado, e é algo que podemos observar em \cite{agarwala2017music}.

\subsection{Deep Learning}
Segundo \cite{aggarwal2018DeepLearning}, redes neurais foram desenvolvidas (inicialmente por \cite{neural1943}) para simular o sistema nervoso humano em máquinas para ``aprenderem'' tarefas similares às executadas pelos neurônios do ser humano. No entanto, tal objetivo não é nem um pouco simples de ser alcançado, considerando que o poder de processamento do mais rápido computador é apenas uma fração da capacidade do cérebro humano. Apesar de tal obstáculo, o aumento do poder computacional e o crescente volume de dados disponíveis permitiu que as redes neurais tivessem maior sucesso em aprender tarefas simples para um ser humano, mas complexas para uma máquina (por exemplo, reconhecimento de imagens). Por conseguinte, ainda segundo \cite{aggarwal2018DeepLearning}, esta área foi renascida com o nome de \textit{deep learning}. 


\subsection{Redes Neurais Recorrentes - RNN}
Segundo \cite{karpathy2015visualizing}, Redes Neurais Recorrentes têm tido sucesso em aplicações que envolvam dados sequenciais (sejam simbólicos ou numéricos). Devido a dificuldade de treino desse tipo de arquitetura de rede neural, diversas propostas de melhorias foram pesquisadas. Dentre as variantes de maior sucesso, podemos destacar a \textit{Long Short Term Memory - LSTM}, proposta por \cite{lstm1997}, que, em princípio, é capaz de armazenar e recuperar informação por longos períodos de tempo.

% texto adaptado?
Entende-se, portanto, que o intuito desta pesquisa é o de reproduzir e verificar os resultados apresentados em \cite{agarwala2017music}. Além de uma discussão das ferramentas de deep learning utilizadas para composição musical, também aplicaremos as técnicas e métodos estudados para a composição de músicas inéditas baseadas em um conjunto personalizado de faixas musicais (trilhas sonoras de jogos, músicas ambientes, entre outras).

\subsection{RNN - Recurrent Neural Network}
% fonte: https://www.ibm.com/cloud/learn/recurrent-neural-networks



\subsubsection{CharRNN}
\subsubsection{LSTM - Long Short Term Memory}

% explicar a arquitetura da rede (com imagens)



\subsection{TensorFLow}
% será que é válido explicar? computação GPU, etc.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Metodologia
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\section{Metodologia}

\subsection{Coleta dos Dados}

% resumo como foram coletados os dados (fonte também) e que isso resultou em error 403 (acesso negado) no site hehe

\subsection{Tratamento dos Dados}

% explicar a forma que tratei os arquivos .abc:
%   - removi títulos
%   - removi letras das músicas
%   - removi caracteres de comentários
%   - codifiquei/vetorizei as strings para que fosse possível ir e vir (caractere --> index e vice-versa)

\subsection{Rede Neural}

% arquiteturas de redes, parâmetros, etc.

\subsection{Pesquisa}

% avaliar percepção humana referente às músicas geradas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Resultados
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Resultados}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Conclusão
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Conclusão}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Próximos Passos
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Próximos Passos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Bibliografia
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\addcontentsline{toc}{chapter}{Referências Bibliográficas} % Coloca no sumário
\bibliographystyle{apalike-br}
\bibliography{biblio}


%\printindex % Opcional  Índice remissivo

\end{document}
